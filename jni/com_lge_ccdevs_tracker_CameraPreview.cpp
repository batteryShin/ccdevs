/* DO NOT EDIT THIS FILE - it is machine generated */
#include <stdio.h>
#include <assert.h>
#include <limits.h>
#include <unistd.h>
#include <fcntl.h>

//#include <utils/threads.h>
//#include <utils/Log.h>
//#include <utils/Errors.h>  // for status_t
#include <core/SkBitmap.h>
#include <android/bitmap.h>

#include <cvjni.h>
#include <highgui.h>

#include <nativehelper/JNIHelp.h>

#include "com_lge_ccdevs_tracker_CameraPreview.h"
#include "FaceDetector.h"
#include "FaceAligner.h"
#include "Tracker.h"

#define TAG_DEBUG "CameraPreview-JNI"

/* Header for class com_lge_ccdevs_tracker_CameraActivity */

#ifdef __cplusplus
extern "C" {
#endif

struct fields_t {
	jclass bitmapClazz;
	jmethodID bitmapConstructor;

	jclass fileClazz;
	jmethodID fileConstructor;

	jclass rectfClazz;
	jfieldID rectf_left_ID;
	jfieldID rectf_top_ID;
	jfieldID rectf_right_ID;
	jfieldID rectf_bottom_ID;
	jfieldID rectfField;
};

static fields_t fields;
static const char* const kClassPathName = "com/lge/ccdevs/tracker/CameraPreview";

JNIEXPORT void JNICALL Java_com_lge_ccdevs_tracker_CameraPreview_native_1cv_1facex
(JNIEnv *env, jobject thiz, jobject srcimg) {
	AndroidBitmapInfo bInfo;
//    uint32_t* bPixs;
    char *bPixs;
	int bRet;
	LOGE("**IN JNI bitmap converter IN!");
	//1. retrieve information about the bitmap
	if ((bRet = AndroidBitmap_getInfo(env, srcimg, &bInfo)) < 0) {
		LOGE("AndroidBitmap_getInfo failed! error = %d", bRet);
		return;
	}
	if (bInfo.format != ANDROID_BITMAP_FORMAT_RGBA_8888) {
		LOGE("Bitmap format is not RGBA_8888!");
		return;
	}

	//2. lock the pixel buffer and retrieve a pointer to it
	if ((bRet = AndroidBitmap_lockPixels(env, srcimg, (void**)&bPixs)) < 0) {
		LOGE("AndroidBitmap_lockPixels() failed! error = %d", bRet);
		return;
	}

	//3. convert bitmap to IplImage
	LOGE("#### Start JNI bitmap processing");
	IplImage* img = cvCreateImage(cvSize(bInfo.width,bInfo.height), IPL_DEPTH_8U, 4);
	memcpy(img->imageData, bPixs, img->imageSize);
	AndroidBitmap_unlockPixels(env, srcimg);

	//4. apply processing
	IplImage* dst = cvCreateImage(cvSize(bInfo.width,bInfo.height), IPL_DEPTH_8U, 4);
	cvCopy(img, dst);

	FaceDetector *detector = new FaceDetector();
	detector->detect_faces(dst);
//	detector->display_faces(dst);

	if(detector->mfaces) {
		FaceAligner *aligner = new FaceAligner();
		CvRect rt_ref = cvRect(0,0,bInfo.width,bInfo.height);
		aligner->align_faces(dst, *(CvRect*)cvGetSeqElem(detector->mfaces,0), rt_ref);
	}

/*
	SkBitmap* bitmap = new SkBitmap;
	bitmap->setConfig(SkBitmap::kARGB_8888_Config, bInfo.width, bInfo.height);
	if( !bitmap->allocPixels() ) {
		android_printLog(ANDROID_LOG_DEBUG, "CheckPoint", "Fail: allocPixels");
		delete bitmap;
		return NULL;
	}

	char *p = (char *)bitmap->getPixels();
	memcpy( p, dst->imageData, dst->imageSize );
*/
	memcpy( bPixs, dst->imageData, dst->imageSize );
	AndroidBitmap_unlockPixels(env, srcimg);

	cvReleaseImage(&img);
	cvReleaseImage(&dst);
	LOGE("#### End processing");

//	return env->NewObject(fields.bitmapClazz, fields.bitmapConstructor, (int)bitmap, p, true, NULL, -1);
	return;
}

JNIEXPORT void JNICALL Java_com_lge_ccdevs_tracker_CameraPreview_native_1cv_1track
(JNIEnv *env, jobject thiz, jobject srcimg, jobject dstimg, jobject rgn) {
	AndroidBitmapInfo bInfo;
    char *bPixs;
	int bRet;

    // convert src_img
	LOGE("**IN JNI bitmap converter IN!");
	if ((bRet = AndroidBitmap_getInfo(env, srcimg, &bInfo)) < 0) {
		LOGE("AndroidBitmap_getInfo failed(src)! error = %d", bRet);
		return;
	}
	if (bInfo.format != ANDROID_BITMAP_FORMAT_RGBA_8888) {
		LOGE("Bitmap(src) format is not RGBA_8888!");
		return;
	}

	if ((bRet = AndroidBitmap_lockPixels(env, srcimg, (void**)&bPixs)) < 0) {
		LOGE("AndroidBitmap_lockPixels() failed(src)! error = %d", bRet);
		return;
	}

	LOGE("#### Start JNI bitmap processing(src)");
	IplImage* src = cvCreateImage(cvSize(bInfo.width,bInfo.height), IPL_DEPTH_8U, 4);
	memcpy(src->imageData, bPixs, src->imageSize);
	AndroidBitmap_unlockPixels(env, srcimg);

    // convert dst_img
	if ((bRet = AndroidBitmap_getInfo(env, dstimg, &bInfo)) < 0) {
		LOGE("AndroidBitmap_getInfo failed(dst)! error = %d", bRet);
		return;
	}
	if (bInfo.format != ANDROID_BITMAP_FORMAT_RGBA_8888) {
		LOGE("Bitmap(dst) format is not RGBA_8888!");
		return;
	}

	if ((bRet = AndroidBitmap_lockPixels(env, dstimg, (void**)&bPixs)) < 0) {
		LOGE("AndroidBitmap_lockPixels() failed(dst)! error = %d", bRet);
		return;
	}

	LOGE("#### Start JNI bitmap processing(dst)");
	IplImage* dst = cvCreateImage(cvSize(bInfo.width,bInfo.height), IPL_DEPTH_8U, 4);
	memcpy(dst->imageData, bPixs, dst->imageSize);
	AndroidBitmap_unlockPixels(env, dstimg);

    // convert RectF
	fields.rectfClazz = env->FindClass("android/graphics/RectF");
    fields.rectf_left_ID = env->GetFieldID(fields.rectfClazz, "left", "F");
    fields.rectf_top_ID = env->GetFieldID(fields.rectfClazz, "top", "F");
    fields.rectf_right_ID = env->GetFieldID(fields.rectfClazz, "right", "F");
    fields.rectf_bottom_ID = env->GetFieldID(fields.rectfClazz, "bottom", "F");

    float left = env->GetFloatField(rgn, fields.rectf_left_ID);
    float top = env->GetFloatField(rgn, fields.rectf_top_ID);
    float right = env->GetFloatField(rgn, fields.rectf_right_ID);
    float bottom = env->GetFloatField(rgn, fields.rectf_bottom_ID);
    LOGE("#### before track = ( %f, %f, %f, %f )",left,top,right,bottom);

	//4. apply processing
	Tracker *tracker = new Tracker(src, cvRect(left,top,right-left,bottom-top));
    CvBox2D res_box = tracker->track(dst);

    float tw = res_box.size.width;
    float th = res_box.size.height;
    float tcx = res_box.center.x;
    float tcy = res_box.center.y;
    left = tcx-tw/2;
    top = tcy-th/2;
    right = tcx+tw/2;
    bottom = tcy+th/2;
    LOGE("#### after tracked = ( %f, %f, %f, %f )",left,top,right,bottom);

    env->SetFloatField(rgn, fields.rectf_left_ID, left);
    env->SetFloatField(rgn, fields.rectf_top_ID, top);
    env->SetFloatField(rgn, fields.rectf_right_ID, right);
    env->SetFloatField(rgn, fields.rectf_bottom_ID, bottom);

    return;
}

#ifdef __cplusplus
}
#endif
